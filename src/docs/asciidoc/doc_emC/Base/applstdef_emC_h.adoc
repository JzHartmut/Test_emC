= applstdef_emC.h in emC
:toc:
:sectnums:
:sectlinks:
:cpp: C++

== Content of applstdef_emC

This file contains some compiler switch definitions and an implementation specifically selection of general header files to support a platform unspecific programming of the user's application using the *_emC_* approach. 

This file is not necessary for driver and unspecific platform adaptions, elsewhere this files uses the *_emC_* exception handling. For exception handling it is necessary to decide through the `applstdef_emC.h` which approach is used. 

If the `applstdef_emC.h` is included in common *_emC_* library sources. Hence this compilation units should be compiled application specific. It is not usefull to store it in an unspecific library. Because: The behavior is even controlled by the application specific `applstdef_emC.h`. Hence a pre-compiled library concept is not adequate for the *_emC_* concept. Libraries can be used to leave it up to the linker to select the necessary objects for a build. But the libraries should be build specific for the application with the given associated `applstdef_emC.h`.

The `applstdef_emC.h` can be adapted to the requirements of the application, other than `compl_adaptio.h` which should be application independent but platform dependent. The `applstdef_emC.h` can be different for several targets where the platform should be running. For example - with exception handling on test of the algorithm on PC, without exception handling for a poor target. 

It means, for 4 applications and 3 targets, only 3 versions of `compl_adaption.h` are necessary, but maybe 12 versions of `applstdef_emC.h`. The differentiation is done by the include path (for the platforms) and the association of `applstdef_emC.h` to the application specific files.  

== Selection of Granulatity of the ObjectJc base class

The `ObjectJc` base class can be used for `struct` or `class` definitions to check the instance's type and to get reflection information. `ObjectJc` can be elaborately used for test platforms because it can refer all symbolic information about the struct's elements. But for an implementation in a simple 'poor' platform it can be reduced at least to only one `int32` value. Of course symbolic information cannot be gotten then, and the type test is reduced to only a number for comparison. But if the platform is 'poor' (less memory) it shouln't be necessary. The important fact is, that a reused library source can be used without change for more or lesser capability of all `ObjectJc` base data. 

In the `applstdef_emC.h` there is decide about the features of `ObjectJc` 

 /**Define the granularity of the ObjectJc base class: */
 #define DEF_ObjectSimple_emC
 #define DEF_ObjectJc_SIMPLE
 //#define DEF_ObjectJc_REFLREF
 //#define DEF_ObjectJcpp_REFLECTION
 //#define DEF_ObjectJc_SYNCHANDLE
 //#define DEF_ObjectJc_OWNADDRESS
 //#define DEF_ObjectJc_LARGESIZE

Some defines should be activated, some are commented. 

* `DEF_ObjectSimple_emC` decides that in `#include <emC/Base/Object_emC.h>` 
only the file `<emC/Base/ObjectSimple_emC.h>` is included, and not the more complex `<emC/Base/ObjectRefl_emC.h>`. It means that the users project should not know a lot of files from the *_emC_* source pool. See link:ObjectJc_en.html#ObjectSimple[]

* `DEF_ObjectJc_SIMPLE` decide that an `ObjectJc` is minimalistic. It contains only a `int32` value, see link:ObjectJc_en.html#ObjectSimple[]. This is possible both for `#define DEF_ObjectSimple_emC` or not, using the more complex `<emC/Base/ObjectRefl_emC.h>`. This form offers only a number to detect the instance type. A base type is not able to quest. Reflection information are not given.

* `DEF_ObjectJc_REFLREF` decide that an `ObjectJc` has a reference to a `ClassJc` instance. Depending on setting `DEF_REFLECTION...` (see next chapter) either only a simple type test is possible, but with base type check, or reflection information of all fields of the type are given either as only offsets using the InspcTargetProxy concept or as full symbolic information.

* `DEF_ObjectJcpp_REFLECTION` decides that the `ObjectJc` data contains an offset from instance address to the `ObjectJc` data. This is necessary for {cpp} usage of reflection information, if the {cpp} `classes` uses virtual tables or a multi inheritance is used. Then the `ObjectJc` is not on position 0 of the class. The offsets of fields in the reflection information are related to the `ObjectJc`. Elsewhere it is not possible to address the fields correctly if an instance is referenced by a base type pointer. This base type can refer another address as the instance address: The address of the base data inside the instance. It should be possible to get `ObjectJc` from any base type, and hence possible to get all instance data, though only the base type is known. Hence this `#define` need to be set for {cpp} usage. It is is combined with `DEF_ObjectSimple_emC` then an instance identifier cannot be stored.     

* `DEF_ObjectJc_SYNCHANDLE` decides that adequate routines for ObjectJc for locking and notify can used as in Java. This `#define` cannot combined with `DEF_ObjectSimple_emC`.  

* `DEF_ObjectJc_OWNADDRESS` decides that the own address of the instance is stored the `ObjectJc` data. This may be necessary if the data are stored as image and some references are existent between this image-stored data. This `#define` cannot combined with `DEF_ObjectSimple_emC`.  

* `DEF_ObjectJc_LARGESIZE`: The `ObjectJc` has always a combination between size and instance id in its first `uint32` word. The size is limited to 64 k-Memory words, if this `#define` is not set. If it is set, the operation `setSizeAndIdent_ObjectJc()` checks the size and sets some special bits to store a size of 1 M or 16 M memory words. Then the number of bits for instance id are reduced. It means there can only be 31 instances with > 1 Mwords, 255 instances > 64 kwords and 4095 instances < 64 kWords. The instance id is only necessary for special approaches, not obligate for all instances. Hence it is a possible restriction. This `#define` cannot combined with `DEF_ObjectSimple_emC`.  

It is possible for example to compile on a target platform with `DEF_ObjectSimple_emC` with sizes till 128 kByte if the target uses 16-bit-memory addresses (the size counts memory addresses, not bytes), but compile the same sources for PC test with `DEF_ObjectJc_LARGESIZE` to handle this data size.  

== Selection of using Reflection

 /**Define of the offering of Reflection information: */
 //#define DEF_REFLECTION_NO
 //#define DEF_REFLECTION_SIMPLE
 #define DEF_REFLECTION_OFFS
 //#define DEF_REFLECTION_FULL

Only one define should be activated, all others should be commented.

* `DEF_REFLECTION_NO` does not use any `ClassJc` instances and is proper for `DEF_ObjectJc_SIMPLE`. 

* `DEF_REFLECTION_SIMPLE` reflects only the type of an instance and uses a simple `ClassJc` definition, see link:ObjectJc_en.html#ObjectSimple[]. This definition supports a simple inheritance. It means it can be detect whether an instance is type of a base class. That is necessary for type check in a base type for in derived instances. But only single inheritance is supported (often sufficient). 

* `DEF_REFLECTION_OFFS` works together with the 'InspcTargetProxy' concept and supports access to all data for a poor target (less memory), with only single inheritance. 

* `DEF_REFLECTION_FULL` uses generated `.refl` files which contains full symbolic information and supports also multi inheritance. It is similar as reflection in Java. The symbolic access can be used for the Inspector as also for symbolic access inside the software, for example for commands to set specific parameter given as textual name and value. 

It is also possible to write specific sources for example with full reflection, including unconditional the `.crefl` file, for example for internal symbolic access even to paramter fields, but usage elsewhere the `_refloffs.c` file or only simple reflection.

== String capabilities

 /**If set then the target should not use string operations */
 //#define DEF_NO_StringUSAGE
 //#define DEF_NO_StringJcCapabilities

This is a possibility to prevent effort for Strings in a poor target. For example a `ClassJc` contains the name as String (`char const*`) , but not if this `#define` is set. It saves some memory. 

An poor target is often used only for numeric calculations. Adequate for a DSP processor (Digital Signal Processor). Often such CPUs are combined on the same board with a organization and communication processor which uses Strings of course. 

* `DEF_NO_StringUSAGE` prevents usage of string literals (`char const*` elements) in emC-Sources, for only numeric usage. 
The application can use String operations of course in its own decision, or can check this `#define` in the application too to difference between platforms and reduce functionality. 

* `DEF_NO_StringJcCapabilities` reduces the possibilities of a `StringJc`. This is a small struct which contains the `char const*` pointer to a String maybe in stack, heap or const, its length (the string itself need not be null-terminated) and some special bits. The struct `StringJc` is anyway existing, but its capability is reduces. See Header for details. 

* `DEF_ClassJc_Vtbl` This is an extra define which can only used with `DEF_REFLECTION_FULL`. It enables an adequate 'virtual table' for C programming using the reflection data structure. This is some more complex than a {Cpp} virtual, but more safe. It is used for a `CharSeqJc` and also in some special sources (Inspector) which were translated from Java. A `CharSeqJc`  has the same format as a `StringJc`. It is a `StringJc` if only a const String is referenced, determined by some bits. But it can act as interface to any specific class (as `java.lang.CharSequence` in comparison with `java.lang.String`). In this case the length element in the `struct` contains the index to the correct operation set for the `CharSequence` virtual table inside the whole table, referenced from the reflection. The `addr` part contains the instance address of this data.            

== ThreadContext and exception handling

The ThreadContext contains thread-local or interupt-local data. Also an interrupt in a poor target without RTOS is a thread. The switch of thread context is very simple, see link:ThCxtExc_emC.html#_thCxt[]. 

 /**If set, without complex thread context, without Stacktrace*/
 //#define DEF_ThreadContext HEAP_emC
 //#define DEF_ThreadContext_STACKTRC
 //#define DEF_ThreadContext_STACKUSAGE
 #define DEF_ThreadContext_STACKTRC_NO
 
The `ThreadContext_emC_s` itself should be seen as mandatory, necessary for Exception handling.

* `DEF_ThreadContext_HEAP_emC` The ThreadContext has also space for some thread local dynamic data. Especially with that an exception message can be prepared in the stack and transferred to this threadlocal heap to help working with elobaretely messages, without organization of an extra space. But this parts should be controlled by `#ifdef DEF_ThreadContext_HEAP_emC` with an `#else` branch with a simple relplacing const string literal. This `#define` can be set independent of the other.     

* `DEF_ThreadContext_STACKTRC` If this `#define` is set the ThreadContext contains a Stacktrace with given number of levels on its initialization, see link:ThCxtExc_emC.html#_thCxt[]. It enables tracking from where a routine was called which has an exception (similar to Java). A Stacktrace level needs two references to the filename and operation name and one `int` for the line. It is about 10 bytes in a 16-bit system with 32 bit addresses. It may be also possible for systems with less memory, if only less levels are used. The Stacktrace does not overflow, on overflow only the last level and the first levels are visible. But on poor targets the number of nested calls may be less anyway.

* `DEF_ThreadContext_STACKUSAGE` If this `#define` is set the macros `STACKTRC_ENTRY(name)` etc. only write the current stack pointer in the `ThreadContext_emC_s` and calculates the maximum. It is a possibility to track the stack usage on debug on runtime. This feature is also activated on `DEF_ThreadContext_STACKTRC`.

* `DEF_ThreadContext_STACKTRC_NO` If this `#define` is set the macros `STACKTRC_ENTRY(name)` etc. are all empty. It means this macros can be used any time, also for a very poor system, it does not produce code under this condition. The exception handling can be used nevertheless because it does not need the stack trace, it does need only the ThreadContext. 


 //#define DEF_Exception_TRYCpp
 #define DEF_Exception_longjmp
 //#define DEF_Exception_NO

Only one of this `#define` should be activated. See link:ThCxtExc_emC.html[]. 

If some sources should be used different exception handling approaches, it can be changed compiling-unit specific (in the source.c file itself or as compiler option). 

* `DEF_Exception_TRYCpp` It works only for {cpp} sources and uses the {cpp} try-catch-throw approach, but with macros defined in link:ThCxtExc_emC.html[] and with a `catch ...` clause. if a source uses `try` `catch` in original {cpp} kind, it is not affected by these settings. 

* `DEF_Exception_longjmp` A longjmp is used in the TRY-CATCH-THROW macros. If {cpp} is used, the destructors are not called on THROW -> CATCH. It means it should not contain necessary code. Instead a `FINALLY` clause should be used.

* `DEF_Exception_NO`: It is for '__well tested__' sources. The `THROW` macro inside the user sources calls a log output (can write some small information somewhere in the memory). The operation does not return, if the return is not programmed. The execution continues after `THROW`. But an information in the stack trace is written, so the `CATCH` block after the normal return is entered. It means the replacement is done though, only the abort of execution is not done.   




== Assertion

The {cpp} `assert()` macro acts depending on too much system header specificas. Hence the macro
`ASSERT_emC(Condition, text, value1, value2)` 
is preferred to use in an application and is used in the emC sources.   

 /**If set, no assertion is done: */
 //#define ASSERT_IGNORE_emC

* `ASSERT_IGNORE_emC`: If this compiler switch is set, the `ASSERT_emC(...)`  macro is empty. It means, the `ASSERT_emC(...)` macro does not produce any code, also the text is not produce. It is for tested systems.  

* If this `#define` is not set, the `ASSERT_emC(...)` macro produces a `THROW` if the condition is false. It means it uses the existing exception handling with its settings. 

See ...TODO assert_emC.html



== Blockheap usage

The `emC/Blockheap/*` are a set of sources which supports a heap with equal size blocks. It prevents fragmentation and supports working with some dynamic memory. 

 /**Selects working with Blockheap*/
 //#define USE_BlockHeap_emC
 //#define DEF_BlockHeap_GARBAGECOLLECTOR


== Definitions for VALTYPE_AddrVal_emC and StringJc-mask

The header file `emC/Base/types_def_common.h` defines a macro:

 #define STRUCT_AddrVal_emC(NAME, TYPE) struct NAME##_T { TYPE* addr; VALTYPE_AddrVal_emC val; } NAME

With this macro typical small `struct` can be defined which contains a memory address together with a integer value. The value can often present the size of a memory part or the number of elements of an array. For example 

 typedef STRUCT_AddrVal_emC(floatARRAY, float);
 
defines such a `struct` for a float array as 

 struct floatARRAY_T { float* addr; int32 val; } floatARRAY;

The intension to do so is, often a size or length information to an array reference is stored anywhere other. It is better to bind both parts. It is a simple and effective C approach. A second, original intension is: Older compiler had returned such a `struct` by value in two processor register. Modern compiler also more complex structures are well handled, but the approach is proper though. An instance can deliver as call-by-value argument too. It means, address and length are bind together in all cases. 

Yet the type of the value should depend on the platform and the requirements of the application (sizes of data). Often and per default `int32` is used, which is proper for 32 bit systems. But for small memory and less requirements, also 16 bit may be sufficient as special case. Only in that case

 #define VALTYPE_AddrVal_emC int16
 
the given type is used, for example for a small 16 bit processor with 64 kByte address space (hence the address has only 16 bit). 

Adequate or matching to that definition the following should be set:

 #define mLength_StringJc 0x03ff

This should match to the `VALTYPE_AddrVal_emC`. In this case it means the maximum of length of a `StringJc` is limited to 1023. It is a condition of the application.  
 

== Specification of safety areas for alloc_MemC()

Allocation is a specific problem. One of the problems is: A programming error can write beyond the memory limits and destroy the whole heap organization. This problem may solved in modern {cpp} programming (may, not is, it depends on the errors).

Another problem is: Embedded software may need more as one heap area for different tasks, respecitively there are different memory areas in a controller. Hence the simple standard `malloc` or `new` is not enough sufficient. `new` can be overridden in {Cpp} by an own `operator new`. Instead `malloc` the *_emC_* offers `void* alloc_MemC(int size)` (`emC/Base/MemC_emC.h`) and a proper `os_allocMem(size)` which can deliver target specific. MS-Windows offers in its API a `LocalAlloc(...)` (`WinBase.h`). All in all it means, the standard-C `malloc` is not the only one possibility to alloc. 

 //#define sizeSafetyArea_allocMemC 256

If this `#define` is activated, the given number of memory locations are added to all allocations. It is for experience. It is possible to set this `#define` in a specific source and only under debug conditions.



== Usage C++

C-source can be compiled with {Cpp} compilation. Usual there should be no problems, else the {Cpp} compiler detects more errors of the programming, really errors which should be corrected. 

But an algorithm should be proper for C compilation if the target should require it. The same sources can be compile with {Cpp} in a test environment or on another target.

The decision between C and {Cpp} compilation is done with compiler options, in the make files. The {Cpp} compilation sets a `#define __cplusplus` internally, which can be checked in the sources.

The user's sources, especially reused parts, can contains both, C routines, C `struct` and {Cpp} classes for usage. See link:ObjectJc_en.html#Cpp[]. But not only the `#ifdef __cplusplus` should decide for usage the classes, else

 #define DEF_cplusplus_emC
 #define DEF_CPP_COMPILE

should be checked. The first one is used inside emC sources. The second one can be used more for the application sources. Both should be set similar. 

== Standard headers

The following headers to include in `applstdef_emC.h`, so all sources can uses its features. 

 #include <compl_adaption.h>
 #include <emC/Base/Assert_emC.h>
 #include <emC_srcApplSpec/applConv/EnhanceRef_simple.h>
 #include <emC/Base/Exception_emC.h>

== reflOffs.h

A `*_reflOffs.c` file is used for a symbolic access to some or all data but without symbolic in the (poor) target, via InspcTargetProxy. This files have to be generated for the whole application. The header file `*_reflOffs.h` should be known by a lot of sources. The sources cannot know which file is it because the name depends on the application, not on the reused source. Hence it should be included in the `applstdef_emC.h` which is responsible to the whole application.

The disadvantage, re-compile unnecessary files (which does not use this information) only if the content of the `*_reflOffs.h` is changed, is not so problematic. The generation of the reflection files is started manually often, then a 'build all' should be done anyway. 


Additionally it can be included: 

 //including the project specific reflOffs.h defines DEF_REFLECTION_OFFS 
 #ifdef DEF_REFLECTION_OFFS
  //contains DEF_REFLOFFS_...for all defined ClassJc
  #include <emC_Exmpl_Ctrl/genRefl/emc_Exmpl_Ctrl_reflOffs.h>
  //Note: the adequate *_reloffs.c should be part of the project:
 #elif defined(DEF_REFLECTION_FULL)
  #define DEF_ClassJc_Vtbl    //It is used in the inspector sources
 #endif

The included header is valid for the whole application and defines which `ClassJc` instances are delivered by a `*_reflOffs.c` file. This can be select in the sources, to define only then `ClassJc` if necessary:

 //Example for a C-file:
 #ifdef DEF_REFLECTION_FULL
  #include "genRefl/Test_Ctrl.crefl"
 #elif !defined(DEFINED_refl_Test_Ctrl) && !defined(DEF_REFLECTION_NO)
  ClassJc const refl_Base_Test_Ctrl = INIZ_ClassJc(refl_Base_Test_Ctrl, "Base_Test_Ctrl");
  ClassJc const refl_Test_Ctrl = INIZsuper_ClassJc(refl_Test_Ctrl, "Test_Ctrl", &refl_Base_Test_Ctrl);
 #endif

For this example the `DEFINED_refl_Test_Ctrl` may defined in the `emc_Exmpl_Ctrl_reflOffs.h`, then the twice definition is prevented.    


== Some more specifics

The `applstdef_emC.h` can contain application specific definitions. For example the `Test_emC\IDE\VS15\applstdef_CppObj\applstdef_emC.h` contains definitions, which main routine should be used for a manual test, or select with the Test gui:

 //
 //What to start as main:
 //
 #define DEF_TESTBasics_emC
 //#define DEF_TESTALL_emC  //this is the setting for the autmatic test.
 //#define DEF_MAIN_emC_TestAll_testSpecialMain
 //#define DEF_MAIN_testMain_ObjectJc
 //#define DEF_MAIN_TestCtrl_emC
 
A main routine can be written in 

 #ifdef DEF_MAIN_TestCtrl_emC
 int main(int nArgs, char** sArgs) {
   ....
 }
 #endif
 
In this kind the application sources can contain more as one main entry, activated with the compiler switch. 

== Example

This is the example of `Test_emC\IDE\VS15\applstdef_CppObj\applstdef_emC.h`, of course under development (2021-01-21)

 #ifndef HGUARD_applstdef_emC
 #define HGUARD_applstdef_emC 
 
 //Projectspecific applstdef_emC.h
 
 /**It seems to be a specifica in Visual Studio. 
  * The VS-File Microsoft Visual Studio 14.0\VC\include\yvals.h
  * contains a assert-message with is prevented with this define. 
  * What ist it, what means it? not clarified yet.
  * Note: This applstdef_emC.h is only for the visual studio project.
  */
 #define _ALLOW_RTCc_IN_STL  //what is it? a specialism of Visual Studio??
 
 //includes the file which is generated from the simulation selector:
 //#include "emC_TestAll/fDefSelection.h"
 
 #ifndef DEFINED_fDefSelection
 
 /**Define the granularity of the ObjectJc base class: */
 //#define DEF_ObjectSimple_emC
 //#define DEF_ObjectJc_SIMPLE
 #define DEF_ObjectJc_REFLREF
 //#define DEF_ObjectJc_SYNCHANDLE
 //#define DEF_ObjectJcpp_REFLECTION
 //#define DEF_ObjectJc_OWNADDRESS
 #define DEF_ObjectJc_LARGESIZE
 
 /**Define of the offering of Reflection information: */
 //#define DEF_REFLECTION_NO
 //#define DEF_REFLECTION_SIMPLE
 #define DEF_REFLECTION_OFFS
 //#define DEF_REFLECTION_FULL
 
 
 /**If set then the target should not use string operations */
 //#define DEF_NO_StringUSAGE
 //#define DEF_NO_StringJcCapabilities
 
 
 /**If set, without complex thread context, without Stacktrace*/
 //#define DEF_ThreadContext_HEAP_emC
 //#define DEF_ThreadContext_STACKTRC
 #define DEF_ThreadContext_STACKUSAGE
 //#define DEF_ThreadContext_STACKTRC_NO
 
 #define DEF_ThreadContext_SIMPLE
 
 //#define DEF_Exception_TRYCpp
 #define DEF_Exception_longjmp
 //#define DEF_Exception_NO
 
 
 //If set, no assertion is done:
 //#define ASSERT_IGNORE_emC
 
 /**Selects working with Blockheap*/
 //#define USE_BlockHeap_emC
 //#define DEF_BlockHeap_GARBAGECOLLECTOR
 
 
 //To work with handle instead pointer in data struct and 
 //DEF_Type_HandleADDR_emC uint32
 
 //for struct{ addr, val}:
 #define VALTYPE_AddrVal_emC int32
 /**Bits of length of constant string adequate to VALTYPE_AddrVal_emC. 
  * It have to be a mask with set bits on right side (all last significant bits).
  * The next 2 bits left are used internally for designation of String.
  * see [[mNonPersists__StringJc]], [[mThreadContext__StringJc]].
  * See also [[kIsCharSequence_StringJc]]
  * The following bits left side are used for enhanced references, see kBitBackRef_ObjectJc and mBackRef_ObjectJc.
  * If enhanced references are not used, a StringJc can occupy all bits, for example all 16 bits for 16-bit-integer systems.
  */
 #define mLength_StringJc                 0x00003fff
 
 
 
 
 //
 //What to start as main:
 //
 #ifndef DEF_TESTBasics_emC
 /**select only one of this to debug special tests: */
 #define DEF_TESTBasics_emC
 //#define DEF_TESTALL_emC  //this is the setting for the autmatic test.
 //#define DEF_MAIN_emC_TestAll_testSpecialMain
 //#define DEF_MAIN_testMain_ObjectJc
 //#define DEF_MAIN_TestCtrl_emC
 #endif //ndef DEF_TESTALL_emC
 
 
 #endif //DEFINED_fDefSelection
 
 
 /**This is to compile C++ classes of emC if __cplusplus is set.
   For C compilation this is ineffective because __cplusplus is necessary too*/
 #define USE_cplusplus_emC
 #define DEF_cplusplus_emC
 #define DEF_CPP_COMPILE
 
 
 #define DEFINED_getVarAddrType_CalcExpr
 
 #define kMaxPathLength_FileDescription_OSAL 512
 //#define sizeSafetyArea_allocMemC 256
 
 
 #include <compl_adaption.h>
 #include <emC/Base/Assert_emC.h>
 #include <emC_srcApplSpec/applConv/EnhanceRef_simple.h>
 #include <emC/Base/Exception_emC.h>
 
 
 
 //including the project specific reflOffs.h defines DEF_REFLECTION_OFFS 
 #ifdef DEF_REFLECTION_OFFS
   //contains DEF_REFLOFFS_...for all defined ClassJc
   #include <emC_Exmpl_Ctrl/genRefl/emc_Exmpl_Ctrl_reflOffs.h>
   //Note: the adequate *.reloffs.c should be part of the project:
 #elif defined(DEF_REFLECTION_FULL)
   #define DEF_ClassJc_Vtbl    //It is used in the inspector sources
 #endif
 
 
 
 
 
 
 
 //only for this test application:
 extern_C void outTestConditions ( );
 
 #endif //HGUARD_applstdef_emC
 


