= ASCII monitor for simple embedded target systems 
:toc:
:toclevels: 5
:sectnums:
:sectlinks:
:max-width: 52em
:prewrap!:
:cpp: C++
:cp: C/++
:wildcard: *


== Approach

under construction

A ascii monitor with free access to all memory addresses is not usefully for access to a device from the user's level view,
but it is a opportunity while developing. 
It may be also possible for service access but only from specialists.

Generally, the connectivity to each device from a network is a proper idea of "Industry of things",
but this is first theory and second not all necessities to access for development and special service 
can be handled by such a "standard" connection. 
A cheap hardware with simple embedded controller has also its limits.

That's why a simple ASCII monitor has its sense, beside user oriented access possibilities of a Human Machine Interface (HMI).

Using a UART connection (asynchron serial) is usual since a long time, already known in the 1960^th^. 
Typical communication boud rates in the earlier time was till 9600 Baud, currently 115 kBaud is usual,
with direct access to Pins with 3.3 V level, often via USB adapter. 

This article describes a ASCII monitor solution as sources in the emC (embedded multiplatform C/++)
which should work on all hardware platforms. 

Additionally, the offered `InspcTargetProxy.exe` as counterpart on PC offers a solution
which can also used to data access via Reflection using the Inspector tool. 
This possibility is also for developing, but on a higher level. See link:../../..//Inspc/index.html[].


== Handling, commands

You can use either a simple serial terminal such as link:https://en.wikipedia.org/wiki/PuTTY[]
or also the `InspcTargetProxy.exe` as monitor tool on PC.

There are one difference on some terminals:
* 1) The terminal sends the key pressed immediately to the target and shows what the target sends back. 
It means that without target nothing is displayed while typing and the target can immediately evaluate
the key strokes, do whatever it want to do with them.
* 2) The other variant is, the line is prepared by the monitor on the PC. 
For example clipboard content can be inserted, and the line can be corrected. 
The complete prepared line is sent if the command will be finished.

For the approach 1) the target should especially also handle a back space key stroke for correcting a command.
It should send back any keystroke immediately as echo. 
Both approaches are supported by the `emC/Inspc/AsciiMoni_emC.*` source.

The commands are spartan. Because: A less memory as buffer should be sufficient for a cheap or poor target.

=== Overview

* q-<enter> switches off a alive message sent from target
* q<enter> switches on the message
* e-<enter> switches off the echo of any received character. Proper for approach 2) of PC-counterpart monitor.
* e<enter> switches on the echo of any received character, default after reset, necessary for approach 1).
* d 0c00 w 8<enter>: Display 8 words (16 bit) from address 0c00
* <enter> Simple press enter: Repeat the last display command
* +<enter> Repeats the last display command but with incremented address. In this kind it is simple to get a memory dump.
* d201080q4<enter> Display 4 quad words (32 bit) from address 201080:
** The address is generally read with 32 bit, and applied in the target as possible (depends on the target address space).
Using a faulty address for the display command should never cause a problem, but this should be asserted by the target programming. 
** use x w q r        