= Test strategies for emC sources (C/C++-Test)
:toc:
:sectnums:


== Directory-tree gradle-conform


Adequate to the guidelines for arrangement of files in gradle, a directory tree has the following structure:

 +-gradle.build   ... build rules
 +-.gitRepository ... contains path to the .git directory
 +-src
   +-main      ... the sources of the module, without test
   |  +-cpp    ... they are C++ and C sources
   |     +-src_emC
   |        +-.git
   |        +-.gitRepository
   |
   +-test    ... all for test
   |  +-cpp    ... they are C++ and C sources
   |  |  +-emC_TestXYZ ... sources for test of special topics
   |  |  +-emC_TestAll
   |  |     +-testmain.cpp  ... test organisation for test of all
   |  |
   |  +-VS15  ... Some test projects in Microsoft visual studio 15
   |  +-EclCDT .. some Test projects in Eclipse
   |  +-TI    ... Test on embedded platform (Texas Instruments CCS)
   |  +-QT    ... maybe Test projects in QT developer ...or other tools
   |  +-ZmakeGcc
   |     +-All_Tests   ... Test scripts in jzTxtCmd for whole test with gcc
   |        +-ZmakeGcc.jzTc.sh
   |
   +-docs       ... place for documentation
     +-asciidoc    ... in Asciidoc


That are all sources, able to commit and compare with git. They are two git repositories present:

* One for this whole tree, including all test things, but not the module sources.

* A second located in Test_emC/src/main/cpp/src_emC: This is the source repository for the emC, able to include in user applications.

To get this repositories from git hub, use

 git clone https://github.com/JzHartmut/Test_emC.git

This gets the Test sources only. But you can start on windows:

 build.bat

or on Linux set executable rights and then start:

 build.sh

to clone the source tree src_emC, load some more tools, compile and test.


== Infrastructure on the PC for Test_emC


The Test can be run under Windows or Linux.

On Windows MinGW or adequate should be installed to support sh.exe for unix shell scripts and to offer the Gnu Compiler suite (gcc).

Java as version JRE8 should be available. java as command line should be invoke JRE8. If another version of java is installed as standard, the PATH of the system can be changed temporary or all scripts should be invoked with a locally changed PATH environment setting.

On a Windows PC I have installed an ordinary git:

 c:\Program Files\git
   <DIR>          bin
   <DIR>          cmd
   <DIR>          dev
   <DIR>          etc
   <DIR>          mingw64
   <DIR>          usr
          152.112 git-bash.exe
          151.600 git-cmd.exe
           18.765 LICENSE.txt
          160.771 ReleaseNotes.html


And MinGW for compilation:


 c:\Programs\MinGW
 <DIR>          bin
 <DIR>          include
 <DIR>          lib
 <DIR>          libexec
 <DIR>          mingw32
 <DIR>          msys
 <DIR>          share
 <DIR>          var
 <DIR>          _dll
 <DIR>          _docu


The folder `_dll' contains


 2016-12-11  23:44           115.214 libgcc_s_dw2-1.dll
 2016-12-11  23:44         1.483.790 libstdc++-6.dll


which are copied from the `c:\Programs\MinGW\bin\` directory. This path `c:\Programs\MinGW\_dll` is in included in the systems `PATH` variable. It is necessary to immediately execute `*.exe`-files which are compiled with MinGW. This both dll are required to execute (The ad

I have written a batch file which is associated to the extension .sh named unix_script.bat :


 @echo off
 set PATH=c:\Programs\MinGW\bin;c:\Programs\MinGW\msys\1.0\bin\; ...
    ... C:\Program Files\git\bin;%PATH%
 set HOMEPATH=\vishia\HOME
 set HOMEDRIVE=D:
 REM -x to output the command as they are executed.
 set SCRIPTPATHB=%1
 set "SCRIPTPATH=%SCRIPTPATHB:\=/%"
 echo %SCRIPTPATH%
 echo on
 sh.exe -c %SCRIPTPATH%

Note that `…​ …`​ is one line. With them a shell script can be executed immediately with double-click, inclusively git commands and mingw execution. The local systems PATH extension includes the git and MinGW executables. The line


 set "SCRIPTPATH=%SCRIPTPATHB:\=/%"


converts the backslash (given on double click in calling argument) to the necessary slash. The `HOMEPATH` and `HOMEDRIVE` variables sets the home directory which is known in Unix/Linux. So you can execute Unix/linux shell scripts nearly usual as in the originals.
aption of the operation system access to Windows). Instead copying the dll you can also include the `c:\Programs\MinGW\bin` in the systems `PATH`, but in my mind it is better to exactly know which dlls are required.

  
== Test strategies: individual and complete tests, documentation

The test of modules (units) has three aspects:

* a) The nightly build test to assure, all is correct. Avoid bugs while improvement.
* b) The manual step by step test to see what is done in detail, the typical developer test. 
* c) Tests document the usage. 

The point a) is the primary for continuous integration. 
The point b) is the most self-evident for the developer, 
one should use firstly this test aspect by himself.
The point c) is the most important for a user of the sources. One can see
how does it works by means of the test (-examples).
  

=== Individual Tests


There are some IDE project files:


* src/test/VS15/All_Test/AllTest_emC_Base.sln: Visual studio


* src/test/EclCDT/emC_Test/.cproject: Eclipse CDT


* TODO maybe QT



Offering special test projects for various topics has not proven successful, because the maintenance of some more projects is a too high effort. Instead, there is exactly one project for any platform (it means two, one for Visual Studio and one for Eclipse CDT), no more. To test a special topic there is a main routine which’s calling statements are commented, only the interesting call is used, for single step in debug. This is simple to make.


 #ifdef DEF_MAIN_emC_TestAll_testSpecialMain
 int main(int nArgs, char const*const* cmdArgs )
 {
   STACKTRC_ROOT_ENTRY("main");
   test_Exception();
   test_stdArray();
   //test_Alloc_ObjectJc();
   test_ObjectJc();
   //testString_emC();


This is a snapshot of the current situation. This main routine is used for both IDE.


The include path is IDE- and configuration-specific in the IDE. For both IDEs different path are used for the


 #include <applstdef_emC.h>


This file(s) should be changed for several Variants for emC compilation. Of course any commit contains the last used situation, not a developer progress in any case.



The applstdef are located in image:../../img/Test_emC/applstdefLocation_VStudio.png[applstdefLocation_VStudio, right]


D:\vishia\emc\Test_emC\src\test\VS15\All_Test
          1.651 AllTest_emC_Base.sln
 <DIR>          applstdef_C1
 <DIR>          applstdef_CppObj




  
== Marking the test routines for complete test

All header files below `src/test/cpp/...` are interfaces for test routines. 
All forward-declared routines in the header files (for C) are candidates to test. 
It is possible to analyse this header files automatically, or it can be assembled
manually in a 'large' test project. 

== What is tested? C-sources, compiler optimization effects and in target hardware

Firstly the algorithm of the C-sources should be tested. 
It should be independent of the used compiler and there options. Hence 
any compiler can be used for test of the sources, 
for example a Visual Studio compiler, gcc or other. 

Secondly, it is possible that an algorithm works proper with the selected compiler,
but fails in practice on an embedded hardware. What is faulty? It is possible 
that the target compiler has better optimization, and a property keyword such as 
`volatile` is missing in the source. It is a real failure in the source,
but it was not detected by the test run with lower optimization.

In conclusion of that, the compiler and its optimization level 
should be carefully set. The test should be done with more as one compiler
and with different optimization levels. For nightly tests the night may long enough. 

The next question is: "Test in the real target hardware". 
An important answer is: 
"The test should not only be done in the special hardware environment,
the sources should be tested in different environment situations". 
For example, an algorithm works properly in the special hardware environment 
because some data are shortened, but the algorithm is really faulty. 
Ergo, test it in different situations. 

But the test in the real target environment, with the target compiler,
running inside the real hardware platform may be the last of all tests. 
It can be done as *integration test* of course, but the modules can be tested
in this manner too. 
 
It means, the test should compile for the target platform, 
load the result into the target hardware, run there, get error messages for example
via a serial output, but run it as module test. 
Because not all modules may be able to load in one binary (it would be too large),
the build and test process should divide the all modules in proper portions 
and test  one after another, or test parallel in more as one hardware board.
  


== Individual tests 

For the developer test the developer can build special projects in his favor IDEs.
This IDE-projects are places in `src/test/VS15` etc. It is recommended to write 
the sources independent of the IDE or C/++ dialect, 
and store a `testmain.c`- source (without header) in the test routines environment.
They are some more `testmain.c` admissible, because that routines are used only
for the individual tests, one per IDE-project. This sources contains the
necessary 

 void main() {
   dospecialTest();
 }
 
to start and step the test under debugging. The routines includes the test headers,
uses the test operations, should not contain tests itself which are usefull for the
nightly tests, but can include special conditions for the individual test.

Because the `main()` invokes the same routine(s) which is/are used for nightly tests,
but only some individual ones, the developer test forces 
the creation of the nightly tests right away.        

== Test environment, mock, dependency injection

The test routines itself calls one or some routines from the module sources 
in an environment arranged in the respective test routine. If instances are necessary,
they are created and removed after test in the test routine. If additional depending
complex modules are necessary, they should be replaces by mock objects because elsewhere
the other module is tested too in a complex non-independent kind. The mock object
should be simple and can contain some helper for checking the test behavior. 
The possible usage of dependency injection instead instantiating of composite objects
inside the test object is a problem of the module source, not a problem of the test itself.

 
== Test check and results

The tests should work silent for nightly tests if they don't fail. It should be possible
to output some information, one line per test, what is tested. 

Test results are checked with macros

 EXPECT_TRUE(condition) << "additional test information";
 
etc., the same macros as used for Google-Tests are used, 
but the whole google test framework itself is not used here. The `EXPECT...`-Macros
are defined in the following kind: 

 #define EXPECT_TRUE(VAL) \
 if(EXPECT_TRUEmsg1(VAL, __FILE__, __LINE__)) std::cerr
 
The routine `EXPECT_TRUEmsg1(...)` returns false if the condition is true, 
if no message should be output.
Hence the `if(...)` construct with the following statement starting with `std:cerr` 
completed with `<< "additional text` in the users code forces the output only on error. 

Only if the test fails, the file and line is reported, after them the user message.
With this information the test can be found out simple by the developer.  

It is a simple writing style for application of this macro. 

The test macros and operations are defined in `org/vishia/emC/Test/testAssert.h` and `~.c` 
in the emC_Base component, able to use in al emC sources out of test too.
