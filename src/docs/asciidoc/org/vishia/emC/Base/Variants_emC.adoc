= applstdef_emC.h and Variants of C-Usage
:toc:
:sectnums:
:sectlinks:
:cpp: C++

== Why variants are necessary

Software for embedded systems should be run under different conditions:

* very fast realtime
* small memory available
* C or {cpp} usage
* elaborately error checks
* safety or fast

The user software itself should not be changed for this challenges, that is the 
concept of _emC_: _embedded multiplatform C/C++_

The possibilities can control the variants for compilation:

* a) choice of a proper include path for `applstdef_emC.h` 
* b) apply a specific `applstdef.h` (which can include one of the standard ones and add some defines)
* c) Set defines as compiler call arguments combined with a)

All three possibilitiess of control are adequate in effect. 
The b) documents the variant in files in the best case. It should be favored.

The emC basic header regard the variants of compiling conditions. 
The user software can call operations, which are really macros specified to the variants.
The user software should not regard the variants. 

One of the basic idea of _emC_ is: *Test in a PC-based high level {cpp} compilation 
environment - and deploy the well tested software on target with the target conditions*.
All sophisticated software checks are done on PC testing, 
the software should be widely error-free after them and can deploy without these checks
on target to run fastly - *without adapting the sources*. 
It means the software can be run and checked again on PC for enhancements, 
without change the sources, and *without sophisticated #ifdef constructs*.  

== Overview over defines for variants of soruce application

=== C++ usage

* `__cplusplus`: Selecting *.c-sources for {cpp} compilation. This can done by compiler switch only.
If {cpp}-Projects are mixed with c-compiled sources, a correct handling of `extern "C"`
is necessary.

=== ObjectJc capability

* `DEF_ObjectJc_SIMPLE`: The basic structure `ObjectJc`, see link:ObjectJc.en.html[ObjectJc.en.html]
can be defined in a elaborately kind (need 6 int32-words, 24 bytes), 
or can be defined as small base `struct` need only 4 byte or 8 bytes on a 32-bit-platform.
The second form does reduce a possible type check and does not support symbolic access.
It may be not necessary in deployed embedded applications.

The full capability of ObjectJc allows 

* derived `struct`for ObjectOrientation in C with type test 
* dynamic linked operation in C with type check 
* ObjectArrayJc

With set `DEF_ObjectJc_SIMPLE` some user algorithm cannot be done. 

* `DEF_ObjectJc_REFLREF`: If this compiler switch is set together with `DEF_ObjectJc_SIMPLE`
than the `ObjectJc` base `struct` contains the reference to its reflection `ClassJc`. 
If `DEF_REFLECTION_NO` is set this causes a compiler error. Only with `DEF_ObjectJc_REFLREF`
a type test can be performed for derived types.

=== String handling

* `DEF_NO_StringJcCapabilities`: Some DSP processors (_Digital Signal Processor_) 
do not handle String operations in a proper way. Only simple `char const*`can be stored.
A String processing is not desired. For that variant this define is set. It reduces
String handling in the basic _emC_ functionality.

* `DEF_ONLY_CHAR_StringJc`

=== Exception and Thread Context

* `DEF_ThreadContext_SIMPLE`: The _thread context_ is a memory area which is thread specific,
or interrupt execution specific too (this is also a thread). The `


* `DEF_HandlePtr64`: In some 64-bit-Applications, for example S-Functions in Simulink, 
all memory addresses of instances (...of Function Blocks) are held in a global accessable 
address table. The references are handles - index to the table, as `uint32` word. 
For deployment the code to a 32-bit-System the same `uint32` words 
as connection data between function blocks (aggregations in UML-slang) contains
the really memory addresses, for fast access. This is regarded by code generation 
in Simulink ((R) Mathworks) - via specific tlc files (tlc = _target language control_).  

=== Reflection handling

There are four alternatives:

* `DEF_REFLECTION_FULL`: The reflection (see link:Reflection.en.html[Reflection.en.html]) 
contains the possibility of symbolic access to all data. 
It can be used for symbolic data access for example via link:Inspector.en.html[Inspector.en.html]
or for symbolic programming. 
The reflection data should be generated by link:CHeader2Reflection.en.html[CHeader2Reflection.en.html].
This should be done for PC test of sources. But in a target system there is no space
for elaborately String reflection information. Then this compiler switch should not be set.

* `DEF_REFLECTION_OFFS`: To prevent effort on target but allow symbolic data access
via the link:Inspector.en.html[Inspector.en.html] tool a _inspector target proxy_ can be used.
That proxy contains the textual information and communicates with the target 
via simple memory content accesses. 
The target should contain generated Reflection information which contains only the offsets#
to all data in a struct, because the offsets may be specific on target compilation
(cannot be presumed by a compiler- and situation-independent tool). 
For that this compiler switch can be set. 

* `DEF_REFLECTION_SIMPLE`: If this macro is set, only type information are contained
in reflection data (Type `ClassJc`) to support safety type checks.

* `DEF_REFLECTION_NO`: Whether type nor symbolic access can be done. 
This is the simplest form - no reflection usage. Instances of `ClassJc` cannot be defined.

Independent of that it can be set:
