##not necessary because unix_script.bat is used anycase: call ..\..\..\src\buildScripts\-setEnv.bat test_Selection.jzT.cmd
#@echo off
#REM invoke from current dir, where this file is stored.
#SET LOGDIR=%CD%\test_Selection_Log_deleteMe
#if not exist %LOGDIR% mkdir %LOGDIR% 
#REM invokes the stimuli selection GUI
#REM Decision which SWT library should be used depends on the java version 32 or 64, not on the Operation System.
#::set SWTJAR=org.eclipse.swt.win32.win32.x86_3.5.1.v3555a.jar  ##for Win32
if test "$OS" = "Windows_NT"; then ##Win64
  CP="libs/vishiaGui.jar;libs/vishiaBase.jar;libs/org.eclipse.swt.win32.win32.x86_64.jar"
else
  CP="libs/vishiaGui.jar:libs/vishiaBase.jar:libs/swt-4.18M1-gtk-linux-x86_64.jar"
fi
#REM if javaw is used, the console window remain open but can be closed manually independent of the java run.
#REM The >out and >err can be used. If start is used here, >out and >err do not work. 
#REM Then no information is given on faulty conditions, especially missing jars.
#REM Therefore 'start' cannot be used here.
#REM write out the command line to help explore the starting conditions on faulty situation:
#@echo on  
cd ../../..
#call -setEnv.bat
pwd
#REM call the GUI. This file %0 is used as argument for SimSelector. It contains all control after the JZtxtcmd label
echo java -cp $CP org.vishia.simSelector.SimSelector src/test/ZmakeGcc/test_Selection.jzT.sh -size:D 
java -cp $CP org.vishia.simSelector.SimSelector src/test/ZmakeGcc/test_Selection.jzT.sh -size:D
#::1>%LOGDIR%\log.txt 2>%LOGDIR%\err.txt

#@echo off
#::type %LOGDIR%\err.txt
#::if errorlevel 1 pause
#REM exit /b means, the console window remain open though this called batch will be finished. exit pure closes the console.
#exit /b 
exit

==JZtxtcmd==

include filesets.jzTc;

currdir = <:><&scriptdir>/../../..<.>;

Class SameChars = org.vishia.util.StringFunctions_B;


Map ccSetDeflt;  ##Settings for compilation

String ccSetDeflt.cc = "gcc";




##not used, not immediately called:
##not used, not immediately called:
##not used, not immediately called:
main() {
  call genTestcases(select="S", name="test_Selection");
}


##
##This routine will be called from inside the Java programm org.vishia.simSelector.SimSelector
##  on the button gen selection. It generates all selected test cases.
##  @args: Map linex contains some named variables which are processed in genSelection(...)
##
sub btnGenSelection(Map line1, Map line2, Map line3, Map line4, Map line5, Map line6){
  Openfile fAllsh = "build/testCurrSel.sh";      ##Helper to execute with "press any key" on end. 
  <+fAllsh>  
  if test -f build/testCurrSel.out; then rm build/testCurrSel.out; fi
  <.+n>
  Openfile fAllBat = "build/testCurrSel.bat";      ##Helper to execute with "press any key" on end. 
  <+fAllBat>
  if exist testCurrSel.out del /S/Q testCurrSel.out
  <.+n>
  call genSelection(line1 = line1, line2 = line2, line3 = line3, line4 = line4, line5 = line5, line6 = line6
              , fAllsh = fAllsh, fAllBat = fAllBat, ccSet=ccSetDeflt, testoutpath=<:>build/testCurrSel.out<.>);
  <+fAllsh>read -n1 -r -p "Press any key to continue..."<.+n>
  fAllsh.close();            
}



##
##This routine will be called from inside the Java programm org.vishia.simSelector.SimSelector
##  on the button with given button text as first argument of this.
##Note: It is the exec key. The gui reads exec1 ... exec4 and creates up to 4 exec keys.
##
sub btnExec1(String button="exec Selection", Map line1, Map line2, Map line3, Map line4, Map line5, Map line6){
  cmd cmd.exe /C start sh.exe -c build/testCurrSel.sh;
}


##
##
##This routine will be called from inside the Java programm org.vishia.simSelector.SimSelector
##  on the button gen testcases. It generates all selected test cases.
##
sub genTestcases ( String select, String name = "testSelectionGUI"
    , Obj ccSet=ccSetDeflt      ##Variables which determines the compilation, setting
        
    ){
  ##T: should be used as the temporary output for debugging, it may be a RAM disk, only temporary
  
  ##if(not File:"T:\".exists() ) {  cmd cmd.exe /C subst T: d:\tmp; }
  <+out><&scriptdir>/<&scriptfile>: genTestcases( name = <&name>, select=
  <&select><.+n>
  Num ixcase = 1;
  Openfile fAllsh = <:>build/<&name>.sh<.>;                         ##build/testCase.sh for all tests 
  ##Openfile fcsv = <:><&dirSimulink>/<&fileTestCases_m>.csv<.>; 
  <+fAllsh>                                                                                                                                                
  <:>
==echo off
==echo all output > build/result/all.out
==if test -e ../build; then cd ..; fi
==if test -f build/result/<&name>.out; then rm build/result/<&name>.out; fi
==if test -f build/result/gcc_nocc.txt; then rm build/result/gcc_nocc.txt; fi
==echo "==== new test select=<&select> ====" > build/result/<&name>.out
==##date >> build/result/<&name>.out ##hint: the date disturbs comparability!
==echo "==================================" >> build/result/<&name>.out   
==#All test cases
==<.><.+>

  Openfile fAllBat = <:>build/<&name>.bat<.>;                         ##build/testCase.bat for all tests                         
  <+fAllBat>                                                                                                                                                
  <:>
==echo all output > build/result/all.out
==::if exist build cd build
==if exist build\result\<&name>.out del /S/Q build\result\<&name>.out
==echo "==== new test select=<&select> ====" >build\result\<&name>.out
==::date >> <&name>.out
==echo "==================================" >>build\result\<&name>.out
==::All test cases
==<.><.+>

  Obj testcases = java org.vishia.testutil.TestConditionCombi.prepareTestCases(select, 6); 
  for(testcase: testcases) { //The order in the testcase is always the order in the tabs.
    Obj lineObj =     tabObj.get(    testcase[0].sel);
    Obj lineRefl =    tabRefl.get(   testcase[1].sel);
    Obj lineStr =     tabStr.get(    testcase[2].sel);
    Obj lineThCxt =   tabThCxt.get(  testcase[3].sel);
    Obj lineExc =     tabExc.get(    testcase[4].sel);
    Obj lineTestSrc = tabTestSrc.get(testcase[5].sel);

    ##<+out>Select: <&lineObj> <.+n> ##<&lineRefl.name> <&lineStr.name> <&lineThCxt.name> <&lineExc.name> <&lineTestSrc.name><.+n>
    <+out>Select: <&lineObj.name> <&lineRefl.name> <&lineStr.name> <&lineThCxt.name> <&lineExc.name> <&lineTestSrc.name><.+n>
    call genSelection(line1=lineObj, line2=lineRefl, line3=lineStr, line4=lineThCxt, line5=lineExc, line6=lineTestSrc
                      , fAllsh = fAllsh, fAllBat = fAllBat, ccSet=ccSet, testoutpath = <:>build/result/<&name>.out<.>);   
    ixcase = ixcase + 1; 

  } ##for testcases
  ##<+fcsv>"Name", "Description", "todo",<.+n>    
  ##<+fAllsh>read -n1 -r -p "Press any key to continue..."<.+n>
  fAllsh.close();      
  <+fAllBat>pause<.+n>
  fAllBat.close();      
  Obj fileAllsh = new java.io.File(<:>build/<&name>.sh<.>);
  fileAllsh.setExecutable(true);   ##for linux, chmod to executable
  ##fcsv.close();
}

     



##
##This operation is kind of common but adapted to the test cases. 
##It is called here from execSelection button and from genTestcases
##
sub genSelection ( Map line1, Map line2, Map line3, Map line4, Map line5, Map line6
    , Obj ccSet      ##Variables which determines the compilation, setting
    , Obj fAllsh
    , Obj fAllBat
    , String testoutpath
    ){

  List defines;                                                                                                                               
  defines += line1.def1;
  if(line1.def2) { 
    defines += line1.def2;
  }
  defines += line2.def1;
  if(line2.def2) { 
    defines += line2.def2;
  }
  defines += line3.def1;
  if(line3.def2) { 
    defines += line3.def2;
  }
  ##
  defines += line4.def1;
  if(line4.def2) { 
    defines += line4.def2;
  }
  defines += line5.def1;
  if(line5.def2) {                                                                                                                                       
    defines += line5.def2;
  }
  defines += line6.def1;
  
  ##testCase is the name of the script file to compile. 
  String testCase = <:>test_<&line1.name>_<&line2.name>_<&line3.name>_<&line4.name>_<&line5.name>_<&line6.name><.>;
  <+out>
  <:>
  Selection creates make_<&testCase>.sh
  <.><.+> 
  ##
  ##                                ## writes to fAllsh, it is the shell script to invoke all tests:
  <+fAllsh><: >
    <:><: >
    echo TEST invokes build/objZmake/make_<&testCase>.sh
====build/objZmake/make_<&testCase>.sh
====<.><.+>
  ##
  ##                                ## writes to fAllBat, it is the shell script to invoke all tests:
  <+fAllBat>
  echo invokes build/objZmake/make_<&testCase>.sh, compile all:
  call unix_script.bat build/objZmake/make_<&testCase>.sh
  <.+>
  ##
  ##                                ## Writes a header for visual Studio test
  Openfile fDefH = "src/test/cpp/emC_TestAll/fDefSelection.h";
  <+fDefH><: >
    <:><: >
    //This file is produced by running the sim selection tool.
====#define DEFINED_fDefSelection
====
====//The next defines contains the selection:
====<:for:define:defines>#define <&define>
====<.for>
====<.><.+>
  fDefH.close();
  ##
  ##                                ## The following subroutine generates the script with compiling statements 
  ##                                ## which invokes the test also.
  call build_dbgC1(testCase=testCase, defines = defines, srcSet = &(line6.srcSet), ccSet=ccSet ); ##srcset_Basics); ##
  ##
  ##                                ## to repeat the specific test only the last one routine need invoked.
}










##Character for test case selection:

##===large tests:
## cannot be combined, either-or, but combined with one of E or select char ThExc and 
## { Test all Reflection full variants, not possible where only } is noted
## } Test all variants of DEF_Object not with REFLECTION_FULL, excluding where only { is noted.

##==group tests
## E Test all Exception variants 


List tabObj @name = 
[ { name="ObjSiSi",   descr="..ObjSiSi",     select="i", def1="DEF_ObjectSimple_emC", def2="DEF_ObjectJc_SIMPLE" }
, { name="ObjSiRefl", descr="..ObjSiRefl",   select="e", def1="DEF_ObjectSimple_emC", def2="DEF_ObjectJc_REFLREF" }
, { name="ObjSimpl",  descr="..ObjSimpl",    select="I", def1="DEF_ObjectJc_SIMPLE" }
, { name="ObjRefl",   descr="..ObjRefl",     select="E", def1="DEF_ObjectJc_REFLREF" }
, { name="ObjCpp",    descr="..ObjCpp",      select="a", def1="DEF_ObjectJcpp_REFLECTION" }
, { name="ObjCppAdr", descr="..ObjCppAdr",   select="A", def1="DEF_ObjectJcpp_REFLECTION", def2="DEF_ObjectJc_OWNADDRESS" }
];

List tabRefl @name = 
[ { name="ReflNo",   descr="..ReflNo",       select="q", def1="DEF_REFLECTION_NO"      }
, { name="ReflSi",   descr="..ReflSi",       select="r", def1="DEF_REFLECTION_SIMPLE"  }
, { name="ReflOffs", descr="..ReflOffs",     select="Q", def1="DEF_REFLECTION_OFFS"    }
, { name="ReflFull", descr="..ReflFull",     select="R", def1="DEF_REFLECTION_FULL"    }
];
                                                                                                                                                       

List tabStr @name = 
[ { name="StrNo",   descr="StrNo",         select="s", def1="DEF_NO_StringJcCapabilities"      }
, { name="StrUse",  descr="StrUse",        select="S", def1="DEF_StringJcCapab_USE"  }
];                                                           

List tabThCxt @name = 
[ { name="ThSimple",       descr="ThSi",   select="0",  def1="DEF_ThreadContext_STACKTRC_NO"}
, { name="ThStackUsg",     descr="ThUsg",  select="2",  def1="DEF_ThreadContext_STACKUSAGE"}
, { name="ThStacktrc",     descr="ThTrc",  select="4",  def1="DEF_ThreadContext_STACKTRC"   }
, { name="ThHeapSimple",   descr="ThHSi",  select="1",  def1="DEF_ThreadContext_STACKTRC_NO", def2="DEF_ThreadContext_HEAP_emC"}
, { name="ThHeapStackUsg", descr="ThHUsg", select="3",  def1="DEF_ThreadContext_STACKUSAGE" , def2="DEF_ThreadContext_HEAP_emC"}
, { name="ThHeapStacktrc", descr="ThHTrc", select="5",  def1="DEF_ThreadContext_STACKTRC"   , def2="DEF_ThreadContext_HEAP_emC"}
                              
];                                                                                                                                               


List tabExc @name = 
[ { name="ExcNo",  descr="ExcNo",  select="n", def1="DEF_Exception_NO" }
, { name="ExcJmp", descr="ExcJmp", select="j", def1="DEF_Exception_longjmp"}
, { name="ExcCpp", descr="ExcCpp", select="t",  def1="DEF_Exception_TRYCpp"}
];


List tabTestSrc @name =                               ##Note: srcsets should be defined above.
[ { name="TestBase",   descr="Test Basics : DEF_TESTBasics_emC",                     select="B", srcSet="srcTestBasics", def1="DEF_TESTBasics_emC"}
, { name="TestEvMsg",  descr="Test Main : DEF_TESTALL_emC",                          select="M", srcSet="srcTestEvMsg",  def1="DEF_TESTALL_emC" }
, { name="TestSpecial",descr="Test with IDE : DEF_MAIN_emC_TestAll_testSpecialMain", select="I", srcSet="srcTestEvMsg",  def1="DEF_MAIN_emC_TestAll_testSpecialMain" }
];



##
##This information will be read from inside the Java programm org.vishia.simSelector.SimSelector
##It determines what is presented in the tables.
##
class ToGui 
{
  List tdata1 = tabObj;
  List tdata2 = tabRefl;
  List tdata3 = tabStr;
  List tdata4 = tabThCxt;
  List tdata5 = tabExc;
  List tdata6 = tabTestSrc;

}






##
##Generates the files for compile and test (shell script)
##This file can be repeated executed after this generation.
##written to build/objZmake/make_<&testCase>.sh
##
sub build_dbgC1 ( String testCase
    , List defines
    , Obj ccSet      ##Variables which determines the compilation, setting
    , Obj srcSet) {
  
  <+out>Generates a file build/make_test_emC.sh for compilation and start test ... 
  <&srcSet>
  <.+n>
  String cc_defh = <:><:for:define:defines> -D <&define><.for> -Isrc/test/ZmakeGcc/applstdef_UseCCdef<.>;
  
  mkdir <:>build/objZmake/<&testCase><.>;
  
  Openfile depArgs = <:>build/objZmake/deps_<&testCase>.args<.>;
  <+depArgs>-currdir:<&currdir><:n><: >                                                                                        
    -obj:build/objZmake/<&testCase>/*.o<:n><: >
    -cfg:src/test/ZmakeGcc/cfgCheckDeps.cfg<:n><: >
    -depAll:build/objZmake/<&testCase>/deps.txt<:n><: >
  <.+>
  
  ##<+makeAll>build/objZmake/make_<&testCase>.sh<.+n>
##  Openfile filedefineDef = <:>build/objZmake/<&testCase>/fDefSelection.h<.>;    ##fDefSelection.h written for manual tests
##  <+filedefineDef><:>//This file is produces by running a test case
##====#define DEFINED_fDefSelection
##====//The next defines contains the selection:
##====<:for:define:defines>#define <&define>
##====<.for>
##====<.><.+close>
  String sMake = <:>build/objZmake/make_<&testCase>.sh<.>;
  <+out>create <&sMake><.+n>
  Openfile makesh = sMake;
  <+makesh># call of compile, link and execute for Test emC_Base with gcc
    <:>
====if test -d ../../src/main; then cd ../..; fi  #is in build directory, should call from SBOX root dir
====if test -d ../src/main; then cd ..; fi
====echo ----------------------------------------------
====echo -
====echo working dir to compile should be the SBOX root                        
====pwd                                                                          ##first invoke checkDeps
====if ! test -d build/result; then mkdir build/result; fi
====if ! test -d build/objZmake/<&testCase>; then mkdir build/objZmake/<&testCase>; fi
====if test -f build/objZmake/<&testCase>/emCBase_.test.exe; then rm build/objZmake/<&testCase>/emCBase_.test.exe; fi
====echo run checkDeps, see output in build/...testCase/checkDeps.out
====java -cp libs/vishiaBase.jar org.vishia.checkDeps_C.CheckDeps --@build/objZmake/deps_<&testCase>.args > build/objZmake/<&testCase>/checkDeps.out 
====rm -f build/objZmake/<&testCase>/gcc*.txt ##clean output files
====rm -f build/result/<&testCase>.cc_err
====
====#rm -r Debug  #for test                                                
====##echo <&testCase> 1> build/objZmake/<&testCase>/compile_Defs.txt
====echo <&testCase> > build/result/<&testCase>.out    
====<:for:define:defines>echo "#define <&define>" >> build/result/<&testCase>.out
====<.for>
====echo Starting compilation >> build/result/<&testCase>.out
====##date >> build/result/<&testCase>.out  ##hint: the date disturbs comparability!
====<.><.+>
  ##                                   ## zmake for compilation, then for link
  zmake <:>build/objZmake/<&testCase>/*.o<.> := ccCompile( &c_src_emC_core
  , &srcSet
  , cc_def = cc_defh, makesh = makesh, depArgs = depArgs, testCase=testCase, ccSet=ccSet
  );
  ##                                   ## link, both zmake write to makesh, see called opration
  zmake <:>build/objZmake/<&testCase>/emCBase_.test.exe<.> := ccLink(&c_src_emC_core
  , &srcSet
  , makesh = makesh, testCase=testCase);                                                                
  
  <+makesh><: >##                          ## statements for execute in the makesh-script
    <:>
====echo End compilation >> build/result/<&testCase>.out
====##date >> build/result/<&testCase>.out  ##hint: the date disturbs comparability!
====if ! test -f build/objZmake/<&testCase>/emCBase_.test.exe; then
====  echo ERROR build/objZmake/<&testCase>/emCBase_.test.exe not built. See linker output.                                                       
====  echo MISSING: <&testCase>/..exe >> build/result/_all_result.txt
====  cat build/result/<&testCase>.cc_err >> build/result/_all.cc_err
====  echo ==========================
====else  
====  echo ==== execute the test ====                  
====  echo TEST   : <&testCase>/..exe >> build/result/_all_result.txt
====  build/objZmake/<&testCase>/emCBase_.test.exe 1>> build/result/<&testCase>.out 2> build/result/<&testCase>.err
====  echo ==== Test cases ==========
====  cat build/result/<&testCase>.out
====  echo
##====  echo ==== Test failures =======
##====  cat build/result/<&testCase>.err
##====  echo
====  echo ==========================
====fi  
====<.><.+>
  
  depArgs.close();
  makesh.close();
  Obj fMake = new java.io.File(sMake);
  fMake.setExecutable(true);           ## for linux, chmod to executable
  <+out>success generate <&sMake><.+n>
}


##
##Creates a snippet in the generated make shell file for compiling all sources with gcc:
##
sub ccCompile(Obj target:org.vishia.cmd.ZmakeTarget
    , String cc_def
    , Obj makesh     ##Openfile for the make.sh file
    , Obj depArgs    ##Openfile for arguments of the checkDeps_C tool
    , Obj ccSet      ##Variables which determines the compilation, setting
    , String testCase) {
  for(c_src1: target.allInputFilesExpanded()) {
    String src1Base = c_src1.basepath();
    if(src1Base.length() >0) { 
      <+depArgs>-src:<&c_src1.basepath()>:<&c_src1.localfile()><.+n>  ##writes the file for checkDeps
    } else {
      <+depArgs>-src:<&c_src1.file()><.+n>  ##writes the file for checkDeps
    }
    ###<+out><&infoDeps><.+n> ##show state, info and file name on console.
    <+makesh><: >
    <:>
    #echo ==== gcc <&c_src1.localfile()> 1>> <&target.output.localdir()>/gcc_err.txt
    if ! test -e <&target.output.localdir()>/<&c_src1.localname()>.o; then
      mkdir -p <&target.output.localdir()>/<&c_src1.localdir()>
      <&ccSet.cc> <&cc_options> -Wa,-adhln <&cc_def> <&inclPath> -o <&target.output.localdir()>/<&c_src1.localname()>.o <&c_src1.file()> 1>> <&target.output.localdir()>/<&c_src1.localname()>.lst 2>> build/result/<&testCase>.cc_err 
      
      if test ! -e <&target.output.localdir()>/<&c_src1.localname()>.o; then 
        echo gcc ERROR: <&c_src1.localfile()>
        echo ERROR: <&c_src1.localfile()> >> build/result/gcc_nocc.txt; 
      else
        echo gcc ok: <&c_src1.localfile()>
      fi
    else
      echo exist: <&c_src1.localfile()>
    fi  
    <.><.+>
  }
}  


##
##Creates a snippet in the generated make shell file for linking all sources with gcc:
##
sub ccLink(Obj target:org.vishia.cmd.ZmakeTarget, Obj makesh, String testCase) {
  <+makesh><: >
  <:>
  if test -e <&target.output.localfile()>; then rm -f test.exe; fi
  g++ -o <&target.output.localfile()><.><.+> 
  for(c_src1: target.allInputFilesExpanded()) {
    <+makesh> <&target.output.localdir()>/<&c_src1.localname()>.o<.+>    
  }
  <+makesh><: >
  <:> <&libs> 1> <&target.output.localdir()>/ld_out.txt 2>> build/result/<&testCase>.cc_err
  echo view build/result/<&testCase>.cc_err for warnings or errors if the test does not run.
  <.><.+>
}

